%matplotlib inline
import matplotlib.pyplot as plt
import numpy as np
#https://srome.github.io/Eigenvesting-III-Random-Matrix-Filtering-In-Finance/

# Definition of the Marchenko-Pastur density
def marchenko_pastur_pdf(x,Q,sigma=1):
    y=1./Q
    eMax=np.power(sigma*(1 + np.sqrt(1./Q)),2) # Largest eigenvalue
    eMin=np.power(sigma*(1 - np.sqrt(1./Q)),2) # Smallest eigenvalue
    return (1/(2*np.pi*sigma*sigma*x*y))*np.sqrt((eMax-x)*(x-eMin)) #*(0 if (x > eMax or x < eMin ) else 1)

def compare_eigenvalue_distribution(correlation_matrix, Q, sigma=1, set_autoscale = True, show_top = True):

correlation_matrix = cor
Q = T/N
sigma=1 
set_autoscale = True
show_top = True
e, _ = np.linalg.eig(correlation_matrix) # Correlation matrix is Hermitian, so this is faster
                           # than other variants of eig

x_min = .0001 if np.power(sigma*(1 - np.sqrt(1./Q)),2) < .0001 else np.power(sigma*(1 - np.sqrt(1./Q)),2)
x_max = np.power(sigma*(1 + np.sqrt(1./Q)),2)
    
fig = plt.figure()
ax  = fig.add_subplot(111)
bins = 50
if not show_top:
    # Clear top eigenvalue from plot
    e=e[ e <= x_max+1]
    
ax.hist(e, normed = True, bins=50) # Histogram the eigenvalues
ax.set_autoscale_on(set_autoscale)
    
    # Plot the theoretical density
    #pdf=pd.Series(marchenko_pastur_pdf(x,Q,sigma=sigma), index=eVal)
f = np.vectorize(lambda x : marchenko_pastur_pdf(x,Q,sigma=sigma))
    
x_min = .0001 if np.power(sigma*(1 - np.sqrt(1./Q)),2) < .0001 else np.power(sigma*(1 - np.sqrt(1./Q)),2)
x_max = np.power(sigma*(1 + np.sqrt(1./Q)),2)

x = np.linspace(x_min,x_max,1000)
pdf = f(x)
#ax.plot(x,f(x), linewidth=4, color = 'r')
plt.plot(x, pdf, linewidth=4, color = 'r')
plt.show()
    
def data():
    np.random.seed(777) #Jackpot
    
    start, end = dt.datetime(2012, 1, 1), dt.datetime(2013, 12, 31)
    tickers = pd.read_csv('yahoo_tickers_2010.csv', header=None)[0]
    tickers = np.random.choice(tickers.values, size=100, replace=False) # Choose a random set of headers
    prices = pd.DataFrame()
    for ticker in tickers:
        try:
            prices[ticker] = DataReader(ticker,'yahoo', start, end).loc[:,'Close']
        except Exception as e:
            pass
    returns = prices.pct_change()
    returns = returns.iloc[1:, :]# Remove first row of NA's generated by pct_changes()
    returns.dropna(axis = 1, thresh=len(returns.index)/2, inplace=True) # Drop stocks with over half the data missing
    returns.dropna(axis = 0, thresh=len(returns.columns), inplace=True) # Drop days without data for all stocks
    training_period = 100
    in_sample = returns.iloc[:(returns.shape[0]-training_period), :].copy()
    tickers = in_sample.columns # Remove tickers that were dropped

    returns.shape #(323, 69)    

if __name__ == '__main__':
    # Create the correlation matrix and find the eigenvalues
N= 1000
T= 10000
X= np.random.normal(0,1,size=(N,T))
cor = np.corrcoef(X)
Q= T/N
compare_eigenvalue_distribution(cor, Q)

